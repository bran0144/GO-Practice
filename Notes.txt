Chapter 1:
Types:
Strings use ""
Use \ to escape (like \n for new line)
string
zero value is empty string

Runes:
Used to represent single characters
Use '' instead of ""
Go uses unicode so just about any char from any language can be a rune

Booleans:
true false
bool
zero value is false

Numbers:
Integers and floats are treated differently
int
float64
zero value is zero (not null)

Operators are the same as in Python + -, etc

Go is statically typed (checked before run time)
to check for type, import "reflect" and use TypeOf()

Variables:

to declare: (it will give it a zero value this way)
var quantity int
var length, width float64
var name string

assignment is =
You can assign multiple variables at the same time
length, width = 2.5, 4.5

can declare and assign at same time and then don't need the type:
var quantity = 20
var length, width = 2.5, 4.5
var name = "Steve"

Using :=
Short variable declaration
quantity := 4
name := "Steve"

Variable name rules:

name must begin with a letter
Begins with a capital letter (than it has been exported)
begins with a small letter (than it can only be used in that package)
Need to use camelcase

use int() to convert types to int

Chapter 2: conditionals/loops
Using methods
replacer := strings.NewReplacer("#", "o")
fixed := replacer.Replace(broken)

Adding comments
(use // for line comments)
(use /* */ for multiline comments)

Handling errors in Go
input, err := reader.ReadString('\n')
problem: what if we never use the err? (then we get a compile error)
Option 1:
Ignore the error:
input, _ := reader.ReadString('\n')

Option 2:
Handle the error:
input, err := reader.ReadString('\n')
log.Fatal(err)  reports the error and stops the program

Problem: some functions and methods return an error value of nil, so we'll get the error even if everything
is okay. So we need to use a conditional.
func main() {
  fmt.Print("Enter a grade: ")
  reader := bufio.NewReader(os.Stdin)
  input, err :- reader.ReadString('\n')
  if err != nil {
      log.Fatal(err)
  }
  fmt.Println(input)
}

Parsing and converting and checking for multiple errors:
func main() {
  fmt.Print("Enter a grade: ")
  reader := bufio.NewReader(os.Stdin)
  input, err :- reader.ReadString('\n')
  if err != nil {
        log.Fatal(err)
  }
  input = strings.TrimSpace(input)
  grade, err := strconv.ParseFloat(input, 64)
  if err != nil {
    log.Fatal(err)
  }
  var status string
  if grade >= 60 {
    status = "passing"
  }else {
    status = "failing"
  }
  fmt.Println("A grade of", grade, "is", status)
}

Note:
you can use the := declaration for err over again because go will just assign instead of declare for the
second variable (as along as one of the two variables are different)

Loops:
for loops:
for t:= 3; t >0; t-- {

}
Initializes t at 3, keeps looping while t is greater than 0, and decrements by 1
++ for incrementing
+= add and assign (to increment or decrement by more than 1, i.e +=5)
init and post statements are optional, but make sure it will eventually evaluate false
x := 1
for x <= 3 {
  fmt.Println(x)
  x++
}

Chapter 3: Functions
String formatting with Printf
fmt.Printf("the %s cost %d cents each.\n", "gumballs", 23)
Verbs
%f - floating point #
%d - decimal integer
%s - string
%t - boolean
%v - value
%T - type of supplied value
%% - literal % sign

To specify decimal places for floats:
fmt.Printf("%%.2f: %.2f\n", 12.3456



}